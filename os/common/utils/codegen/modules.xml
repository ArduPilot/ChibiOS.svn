<?xml version="1.0" encoding="UTF-8"?>
<!-- Class/interfaces definitions -->
<instance
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd">
  <configuration_settings>
  </configuration_settings>
  <modules>
    <module name="oop_base_object">
      <doc>
        <brief>Common ancestor abstract class.</brief>
        <details>This abstract class is the common ancestor of all classes
used in ChibiOS. This class just defines the position of the VMT pointer
inside the structure.</details>
        <note>This is a generated file, do not edit directly.</note>
      </doc>
      <inclusions>
        <include scope="global" style="regular">osal.h</include>
      </inclusions>
      <macros>
        <macro name="oopGetInstance">
          <brief>Returns the object instance pointer starting from an interface pointer.</brief>
          <details>
Because multiple inheritance, an object can be composed by
multiple interfaces and/or classes (its ancestors).
This function returns the pointer to the base object starting
from a pointer to any of its composing classes or interfaces.
This is done by leveraging the offset field into each VMT table.
          </details>
          <param name="c">The class type of the object.</param>
          <param name="p">A pointer to one of the object composing classes or interfaces.</param>
          <return>A pointer to an object of type @p c implementing the interface/class @p p.</return>
          <implementation><![CDATA[
(c)(((size_t)(ip)) - (**(size_t **)(p)))]]>
          </implementation>
        </macro>
      </macros>
      <typedefs>
      </typedefs>
      <classes>
        <class name="base_object" ancestor="" descr="base object" type="abstract">
          <details>
          </details>
          <fields>
          </fields>
          <init>
            <implementation><![CDATA[ ]]></implementation>
          </init>
          <dispose>
            <implementation><![CDATA[ ]]></implementation>
          </dispose>
          <methods>
          </methods>
        </class>
      </classes>
    </module>
    <module name="oop_referenced_object">
      <doc>
        <brief>Common ancestor class of all reference-counted objects.</brief>
        <details>Base class for objects that implement a reference counter
and are disposed when the number of references reaches zero. This class
extends @p base_object_c class.</details>
        <note>This is a generated file, do not edit directly.</note>
      </doc>
      <inclusions>
        <include scope="global" style="angular">oop_base_object.h</include>
      </inclusions>
      <typedefs>
        <typedef ctype="object_references_t">
          <brief>Type of a references counter.</brief>
          <reftype ctype="unsigned int" />
        </typedef>
      </typedefs>
      <classes>
        <class name="referenced_object" ancestor="base_object" descr="referenced object" type="abstract">
          <details>
          </details>
          <fields>
            <field name="references" ctype="object_references_t" />
          </fields>
          <init>
            <implementation><![CDATA[ ]]></implementation>
          </init>
          <dispose>
            <implementation><![CDATA[ ]]></implementation>
          </dispose>
          <methods>
            <method name="roAddRef" shortname="addref" ctype="void *" type="virtual">
              <brief>New object reference creation.</brief>
              <details>The references counter is increased and a new reference pointer is returned.</details>
              <return>A new reference pointer.</return>
              <implementation><![CDATA[
self->references++;

osalDbgAssert(self->references != (oop_object_references_t)0, "overflow");

return self;]]></implementation>
            </method>
            <method name="roRelease" shortname="release" ctype="object_references_t" type="virtual">
              <brief>Release of an object reference.</brief>
              <details>The reference counter is decreased, if the counter reaches zero then the object is disposed.</details>
              <return>The value of the reference counter.</return>
              <implementation><![CDATA[
osalDbgAssert(self->references > 0U, "zero references");

if (--self->references == 0U) {
  __referenced_object_dispose_impl(self);
}

return self->references;]]></implementation>
            </method>
          </methods>
        </class>
      </classes>
    </module>
  </modules>
</instance>
