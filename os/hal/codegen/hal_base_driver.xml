<?xml version="1.0" encoding="UTF-8"?>
<module xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd"
  name="hal_base_driver">
  <brief>Common driver base abstract class.</brief>
  <details>This abstract class is the common ancestor of all HAL
    stateful HAL drivers.
  </details>
  <note>This is a generated file, do not edit directly.</note>
  <public>
    <definitions_early>
      <group description="Common driver states">
        <define name="HAL_DRV_STATE_UNINIT" value="0U" />
        <define name="HAL_DRV_STATE_STOP" value="1U" />
        <define name="HAL_DRV_STATE_READY" value="2U" />
        <define name="HAL_DRV_STATE_ACTIVE" value="3U" />
        <define name="HAL_DRV_STATE_ERROR" value="4U" />
      </group>
    </definitions_early>
    <configs>
      <config name="HAL_USE_MUTUAL_EXCLUSION" default="TRUE">
        <brief>Enables the mutual exclusion APIs on driver
          instances.</brief>
        <note>Disabling this option saves both code and data space.</note>
        <assert invalid="($N != FALSE) &amp;&amp; ($N != TRUE)" />
      </config>
      <config name="HAL_USE_REGISTRY" default="FALSE">
        <brief>Enables the HAL registry for drivers.</brief>
        <note>Disabling this option saves both code and data space.</note>
        <assert invalid="($N != FALSE) &amp;&amp; ($N != TRUE)" />
      </config>
    </configs>
    <macros>
    </macros>
    <types>
      <typedef name="driver_state_t">
        <brief>Type of a driver state variable.</brief>
        <basetype ctype="unsigned int" />
      </typedef>
    </types>
    <classes>
      <class name="hal_base_driver" namespace="drv" ancestor="bo" descr="HAL base driver"
        type="abstract">
        <brief>
        </brief>
        <fields>
          <field name="state" ctype="driver_state_t" />
          <field name="opencnt" ctype="unsigned int" />
          <field name="owner" ctype="void$I*" />
          <condition check="HAL_USE_MUTUAL_EXCLUSION == TRUE">
            <field name="mutex" ctype="mutex_t" />
          </condition>
        </fields>
        <methods>
          <objinit>
            <implementation><![CDATA[
self->drv.state   = HAL_DRV_STATE_STOP;
self->drv.opencnt = 0U;
self->drv.owner   = NULL;
osalMutexObjectInit(&self->drv.mutex);
#if HAL_USE_REGISTRY == TRUE
self->drv.id      = 0U;
#endif]]></implementation>
          </objinit>
          <dispose>
            <implementation><![CDATA[ ]]></implementation>
          </dispose>
          <virtual>
            <method name="__drv_start_protected" shortname="start" ctype="msg_t">
              <brief>Low level driver start.</brief>
              <return>The operation status.</return>
            </method>
            <method name="__drv_stop_protected" shortname="stop" ctype="void">
              <brief>Low level driver stop.</brief>
            </method>
            <method name="drvConfigureX" shortname="configure" ctype="msg_t">
              <brief>Driver configure.</brief>
              <details>Applies a new configuration to the driver. The configuration
                structure is
                architecture-dependent.</details>
              <note>Applying a configuration should be done while the peripheral
                is not actively
                operating, this function can fail depending
                on the driver implementation and
                current state.</note>
              <param ctype="const void *" name="config">New driver configuration.</param>
            </method>
          </virtual>
          <regular>
            <method name="drvOpen" ctype="msg_t">
              <brief>Driver open.</brief>
              <details>Returns a reference to the driver, on the 1st open the peripheral
                is
                physically initialized. An implementation-dependent default
                configuration is used
                for initialization.</details>
              <return>The operation status.</return>
              <implementation><![CDATA[
msg_t msg;

osalDbgCheck(self != NULL);

osalSysLock();

if (self->drv.opencnt == 0U) {
  /* Physically starting the peripheral.*/
  msg = __drv_start_protected(self);
  if (msg == HAL_RET_SUCCESS) {
    self->drv.opencnt++;
    self->drv.state = HAL_DRV_STATE_READY;
  }
  else {
    self->drv.state = HAL_DRV_STATE_STOP;
  }
}
else {
  msg = HAL_RET_SUCCESS;
}

osalSysUnlock();

return msg;]]></implementation>
            </method>
            <method name="drvClose" ctype="void">
              <brief>Driver close.</brief>
              <details>Releases a reference to the driver, when the count reaches zero
                then the
                peripheral is physically uninitialized.</details>
              <implementation><![CDATA[
osalDbgCheck(self != NULL);

osalSysLock();

osalDbgAssert(self->drv.opencnt > 0U, "not opened");

if (--self->drv.opencnt == 0U) {
  self->drv.state = HAL_DRV_STATE_STOP;
  __drv_stop_protected(self);
}

osalSysUnlock();]]></implementation>
            </method>
            <method name="drvGetStateX" ctype="driver_state_t">
              <brief>Driver state get.</brief>
              <return>The driver state.</return>
              <implementation><![CDATA[return self->drv.state;]]></implementation>
            </method>
            <method name="drvSetStateX" ctype="void">
              <brief>Driver state set.</brief>
              <param ctype="driver_state_t" name="state">New driver
                  state.</param>
              <implementation><![CDATA[self->drv.state = state;]]></implementation>
            </method>
            <method name="drvGetOwnerX" ctype="void *">
              <brief>Driver owner get.</brief>
              <return>The driver owner.</return>
              <implementation><![CDATA[return self->drv.owner;]]></implementation>
            </method>
            <method name="drvSetOwnerX" ctype="void">
              <brief>Driver owner set.</brief>
              <param ctype="void *" name="owner">New driver owner.</param>
              <implementation><![CDATA[self->drv.owner = owner;]]></implementation>
            </method>
            <condition check="HAL_USE_MUTUAL_EXCLUSION == TRUE">
              <method name="drvLock" ctype="void">
                <brief>Driver lock.</brief>
                <implementation><![CDATA[osalMutexLock(&self->drv.mutex);]]></implementation>
              </method>
              <method name="drvUnlock" ctype="void">
                <brief>Driver unlock.</brief>
                <implementation><![CDATA[osalMutexUnlock(&self->drv.mutex);]]></implementation>
              </method>
            </condition>
          </regular>
        </methods>
      </class>
    </classes>
  </public>
  <private>
    <inclusions>
      <include style="regular">hal.h</include>
    </inclusions>
  </private>
</module>
