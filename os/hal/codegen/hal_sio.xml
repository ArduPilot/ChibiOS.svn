<?xml version="1.0" encoding="UTF-8"?>
<module xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd"
  name="hal_sio_test" check="HAL_USE_SIO == TRUE">
  <brief>SIO Driver macros and structures.</brief>
  <note>This is a generated file, do not edit directly.</note>
  <public>
    <definitions_early>
      <group description="SIO masks offset">
        <define name="SIO_EV_RXNOTEMPY_POS"
          value="CHN_INPUT_AVAILABLE_POS" />
        <define name="SIO_EV_TXNOTFULL_POS"
          value="CHN_OUTPUT_EMPTY_POS" />
        <define name="SIO_EV_TXDONE_POS"
          value="CHN_TRANSMISSION_END_POS" />
        <define name="SIO_EV_ALL_ERRORS_POS"
          value="CHN_PARITY_ERROR_POS" />
        <define name="SIO_EV_PARITY_ERR_POS"
          value="CHN_PARITY_ERROR_POS" />
        <define name="SIO_EV_FRAMING_ERR_POS"
          value="CHN_FRAMING_ERROR_POS" />
        <define name="SIO_EV_NOISE_ERR_POS"
          value="CHN_NOISE_ERROR_POS" />
        <define name="SIO_EV_OVERRUN_ERR_POS"
          value="CHN_OVERRUN_ERROR_POS" />
        <define name="SIO_EV_RXIDLE_POS"
          value="CHN_IDLE_DETECTED_POS" />
        <define name="SIO_EV_RXBREAK_POS"
          value="CHN_BREAK_DETECTED_POS" />
      </group>
      <group
        description="Event flags (compatible with channel and serial events)">
        <define name="SIO_EV_NONE" value="0U" />
        <define name="SIO_EV_RXNOTEMPY"
          value="(1U &lt;&lt; SIO_EV_RXNOTEMPY_POS" />
        <define name="SIO_EV_TXNOTFULL"
          value="(1U &lt;&lt; SIO_EV_TXNOTFULL_POS" />
        <define name="SIO_EV_ALL_DATA"
          value="(SIO_EV_RXNOTEMPY | SIO_EV_TXNOTFULL)" />
        <define name="SIO_EV_TXDONE"
          value="(1U &lt;&lt; SIO_EV_TXDONE_POS" />
        <define name="SIO_EV_PARITY_ERR"
          value="(1U &lt;&lt; SIO_EV_PARITY_ERR_POS" />
        <define name="SIO_EV_FRAMING_ERR"
          value="(1U &lt;&lt; SIO_EV_FRAMING_ERR_POS" />
        <define name="SIO_EV_NOISE_ERR"
          value="(1U &lt;&lt; SIO_EV_NOISE_ERR_POS" />
        <define name="SIO_EV_OVERRUN_ERR"
          value="(1U &lt;&lt; SIO_EV_OVERRUN_ERR_POS" />
        <define name="SIO_EV_RXIDLE"
          value="(1U &lt;&lt; SIO_EV_RXIDLE_POS" />
        <define name="SIO_EV_RXBREAK"
          value="(1U &lt;&lt; SIO_EV_RXBREAK_POS" />
        <define name="SIO_EV_ALL_ERRORS"
          value="(SIO_EV_PARITY_ERR | SIO_EV_FRAMING_ERR | SIO_EV_OVERRUN_ERR | SIO_EV_NOISE_ERR | SIO_EV_RXBREAK)" />
        <define name="SIO_EV_ALL_EVENTS"
          value="(SIO_EV_ALL_DATA | SIO_EV_ALL_ERRORS | SIO_EV_TXDONE | SIO_EV_RXIDLE)" />
      </group>
      <group description="Additional messages">
        <define name="SIO_MSG_ERRORS" value="1" />
      </group>
    </definitions_early>
    <configs>
      <config name="SIO_DEFAULT_BITRATE" default="38400">
        <brief>Default bit rate.</brief>
        <details>Configuration parameter, this is the baud rate selected
          for the default configuration.
        </details>
        <assert invalid="$N &lt;= 0" />
      </config>
      <config name="SIO_USE_SYNCHRONIZATION" default="TRUE">
        <brief>Support for thread synchronization API.</brief>
        <assert invalid="($N != FALSE) &amp;&amp; ($N != TRUE)" />
      </config>
      <config name="SIO_USE_STREAMS_INTERFACE"
        default="SIO_USE_SYNCHRONIZATION">
        <brief>Support for streams interface.</brief>
        <assert invalid="($N != FALSE) &amp;&amp; ($N != TRUE)" />
      </config>
    </configs>
    <macros>
      <macro name="sioSetCallbackX">
        <brief>Associates a callback to the SIO instance.</brief>
        <param name="siop" dir="out">pointer to the @p hal_sio_driver_c object</param>
        <param name="f">callback function to be associated</param>
        <implementation><![CDATA[(siop)->sio.cb = (f)]]></implementation>
      </macro>
      <macro name="sioIsRXEmptyX">
        <brief>Determines the state of the RX FIFO.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The RX FIFO state.</return>
        <implementation><![CDATA[sio_lld_is_rx_empty(siop)]]></implementation>
      </macro>
      <macro name="sioIsRXIdleX">
        <brief>Determines the activity state of the receiver.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The RX activity state.</return>
        <implementation><![CDATA[sio_lld_is_rx_idle(siop)]]></implementation>
      </macro>
      <macro name="sioHasRXErrorsX">
        <brief>Determines if RX has pending errors to be read and
          cleared.
        </brief>
        <note>Only error flags are handled, data and idle flags are not
          considered.
        </note>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The RX error events.</return>
        <implementation><![CDATA[sio_lld_has_rx_errors(siop)]]></implementation>
      </macro>
      <macro name="sioIsTXFullX">
        <brief>Determines the state of the TX FIFO.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The TX FIFO state.</return>
        <implementation><![CDATA[sio_lld_is_tx_full(siop)]]></implementation>
      </macro>
      <macro name="sioIsTXOngoingX">
        <brief>Determines the transmission state.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The transmission state.</return>
        <implementation><![CDATA[sio_lld_is_tx_ongoing(siop)]]></implementation>
      </macro>
      <macro name="sioWriteEnableFlagsX">
        <brief>Writes the enabled events mask.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="mask" dir="in">enabled events mask to be written</param>
        <implementation><![CDATA[
do {
  (siop)->sio.enabled = (mask);
  sio_lld_update_enable_flags(siop);
} while (false)]]></implementation>
      </macro>
      <macro name="sioSetEnableFlagsX">
        <brief>Sets flags into the enabled events flags mask.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="mask" dir="in">enabled events mask to be set</param>
        <implementation><![CDATA[
do {
  (siop)->sio.enabled |= (mask);
  sio_lld_update_enable_flags(siop);
} while (false)]]></implementation>
      </macro>
      <macro name="sioClearEnableFlagsX">
        <brief>Clears flags from the enabled events flags mask.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="mask" dir="in">enabled events mask to be cleared</param>
        <implementation><![CDATA[
do {
  (siop)->sio.enabled &= ~(mask);
  sio_lld_update_enable_flags(siop);
} while (false)]]></implementation>
      </macro>
      <macro name="sioGetEnableFlagsX">
        <brief>Gets the enabled condition flags mask.</brief>
        <param name="siop" dir="in">pointer to the @p hal_sio_driver_c object</param>
        <return>The enabled event flags.</return>
        <implementation><![CDATA[(siop)->sio.enabled]]></implementation>
      </macro>
      <macro name="sioGetAndClearErrorsX">
        <brief>Gets and clears SIO error flags.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The pending error flags.</return>
        <implementation><![CDATA[sio_lld_get_and_clear_errors(siop)]]></implementation>
      </macro>
      <macro name="sioGetAndClearEventsX">
        <brief>Gets and clears SIO event flags.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The pending event flags.</return>
        <implementation><![CDATA[sio_lld_get_and_clear_events(siop)]]></implementation>
      </macro>
      <macro name="sioGetEventsX">
        <brief>Returns all SIO event flags.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The pending event flags.</return>
        <implementation><![CDATA[sio_lld_get_events(siop)]]></implementation>
      </macro>
      <macro name="sioGetX">
        <brief>Returns one frame from the RX FIFO.</brief>
        <note>If the FIFO is empty then the returned value is
          unpredictable.
        </note>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <return>The frame from RX FIFO.</return>
        <implementation><![CDATA[sio_lld_get(siop)]]></implementation>
      </macro>
      <macro name="sioPutX">
        <brief>Pushes one frame into the TX FIFO.</brief>
        <note>If the FIFO is full then the behavior is unpredictable.</note>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="data" dir="in">frame to be written</param>
        <implementation><![CDATA[sio_lld_put(siop, data)]]></implementation>
      </macro>
      <macro name="sioAsyncReadX">
        <brief>Reads data from the RX FIFO.</brief>
        <details>This function is non-blocking, data is read if present
          and the effective amount is returned.
        </details>
        <note>This function can be called from any context but it is
          meant to be called from the @p cb callback handler.
        </note>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="size" dir="in">maximum number of frames to read</param>
        <param name="buffer" dir="out">buffer for the received data</param>
        <return>The number of received frames.</return>
        <implementation><![CDATA[sio_lld_read(siop, size, buffer)]]></implementation>
      </macro>
      <macro name="sioAsyncWriteX">
        <brief>Writes data into the TX FIFO.</brief>
        <details>This function is non-blocking, data is written if there
          is space in the FIFO and the effective amount is returned.
        </details>
        <note>This function can be called from any context but it is
          meant to be called from the @p cb callback handler.
        </note>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="size" dir="in">maximum number of frames to read</param>
        <param name="buffer" dir="in">buffer containing the data to be transmitted</param>
        <return>The number of transmitted frames.</return>
        <implementation><![CDATA[sio_lld_write(siop, size, buffer)]]></implementation>
      </macro>
      <macro name="sioControlX">
        <brief>Control operation on a serial port.</brief>
        <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
        <param name="operation" dir="in">control operation code</param>
        <param name="arg" dir="both">operation argument</param>
        <return>The control operation status.</return>
        <implementation><![CDATA[sio_lld_control(siop, operation, arg)]]></implementation>
      </macro>
      <group description="Low level driver helper macros">
        <macro name="__sio_callback">
          <brief>SIO callback.</brief>
          <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
          <return>The control operation status.</return>
          <implementation><![CDATA[
do {
  if ((siop)->sio.cb != NULL) {
    (siop)->sio.cb(siop);
  }
} while (false)]]></implementation>
        </macro>
        <condition check="SIO_USE_SYNCHRONIZATION == TRUE">
          <macro name="__sio_wakeup_errors">
            <brief>Wakes up because RX errors.</brief>
            <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
            <implementation><![CDATA[
do {
  osalSysLockFromISR();
  osalThreadResumeI(&(siop)->sio.sync_rx, SIO_MSG_ERRORS);
  osalThreadResumeI(&(siop)->sio.sync_rxidle, SIO_MSG_ERRORS);
  osalSysUnlockFromISR();
} while (false)]]></implementation>
          </macro>
          <macro name="__sio_wakeup_rx">
            <brief>Wakes up the RX-waiting thread.</brief>
            <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
            <implementation><![CDATA[
do {
  osalSysLockFromISR();
  osalThreadResumeI(&(siop)->sio.sync_rx, MSG_OK);
  osalSysUnlockFromISR();
} while (false)]]></implementation>
          </macro>
          <macro name="__sio_wakeup_rxidle">
            <brief>Wakes up the RX-idle-waiting thread.</brief>
            <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
            <implementation><![CDATA[
do {
  osalSysLockFromISR();
  osalThreadResumeI(&(siop)->sio.sync_rxidle, MSG_OK);
  osalSysUnlockFromISR();
} while (false)]]></implementation>
          </macro>
          <macro name="__sio_wakeup_tx">
            <brief>Wakes up the TX-waiting thread.</brief>
            <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
            <implementation><![CDATA[
do {
  osalSysLockFromISR();
  osalThreadResumeI(&(siop)->sio.sync_tx, MSG_OK);
  osalSysUnlockFromISR();
} while (false)]]></implementation>
          </macro>
          <macro name="__sio_wakeup_txend">
            <brief>Wakes up the TXend-waiting thread.</brief>
            <param name="siop" dir="both">pointer to the @p hal_sio_driver_c object</param>
            <implementation><![CDATA[
do {
  osalSysLockFromISR();
  osalThreadResumeI(&(siop)->sio.sync_txend, MSG_OK);
  osalSysUnlockFromISR();
} while (false)]]></implementation>
          </macro>
          <elseif />
          <macro name="__sio_wakeup_errors">
            <param name="siop" />
          </macro>
          <macro name="__sio_wakeup_rx">
            <param name="siop" />
          </macro>
          <macro name="__sio_wakeup_rxidle">
            <param name="siop" />
          </macro>
          <macro name="__sio_wakeup_tx">
            <param name="siop" />
          </macro>
          <macro name="__sio_wakeup_txend">
            <param name="siop" />
          </macro>
        </condition>
      </group>
      <macro name="__sio_reloc_field">
        <brief>Relocates a bit field.</brief>
        <param name="v" dir="in">value</param>
        <param name="m" dir="in">mask of the bit field</param>
        <param name="s" dir="in">source bit offset</param>
        <param name="d" dir="in">destination bit offset</param>
        <implementation><![CDATA[((((v) & m) >> (s)) << (d))]]></implementation>
      </macro>
    </macros>
    <types>
      <typedef name="sioevents_t">
        <brief>Type of SIO event flags.</brief>
        <basetype ctype="eventflags_t" />
      </typedef>
      <typedef name="hal_sio_config_t">
        <brief>Type of structure representing a SIO configuration.</brief>
        <basetype ctype="struct hal_sio_config" />
      </typedef>
      <typedef name="SIOConfig">
        <brief>Type of structure representing a SIO configuration
          (legacy).
        </brief>
        <basetype ctype="struct hal_sio_config" />
      </typedef>
      <typedef name="SIODriver">
        <brief>Type of structure representing a SIO driver (legacy).</brief>
        <basetype ctype="struct hal_sio_driver" />
      </typedef>
      <typedef name="siocb_t">
        <brief>Generic SIO notification callback type.</brief>
        <basetype ctype="void (*$N)(struct hal_sio_driver *siop)" />
      </typedef>
      <verbatim><![CDATA[
/* Inclusion of LLD header.*/
#include "hal_sio_lld.h"]]></verbatim>
    </types>
    <classes>
      <class name="hal_sio_driver" namespace="sio"
        ancestor="hal_base_driver" descr="SIO driver" type="regular">
        <brief>
        </brief>
        <fields>
          <condition check="SIO_USE_STREAMS_INTERFACE == TRUE">
            <field name="chn"
              ctype="base_channel_i">
              <brief>Channel interface.</brief>
            </field>
          </condition>
          <field name="enabled" ctype="sioevents_t">
            <brief>Enabled event flags.</brief>
          </field>
          <field name="cb" ctype="siocb_t">
            <brief>Events callback.</brief>
            <note>Can be @p NULL.</note>
          </field>
          <condition check="HAL_USE_MUTUAL_EXCLUSION == TRUE">
            <field name="sync_rx" ctype="thread_reference_t">
              <brief>Synchronization point for RX.</brief>
            </field>
            <field name="sync_rxidle" ctype="thread_reference_t">
              <brief>Synchronization point for RX idle.</brief>
            </field>
            <field name="sync_tx" ctype="thread_reference_t">
              <brief>Synchronization point for TX.</brief>
            </field>
            <field name="sync_txend" ctype="thread_reference_t">
              <brief>Synchronization point for TX-end.</brief>
            </field>
          </condition>
          <verbatim><![CDATA[
#if defined(SIO_DRIVER_EXT_FIELS)
SIO_DRIVER_EXT_FIELDS
#endif
/* End of the mandatory fields.*/
sio_lld_driver_fields;]]></verbatim>
        </fields>
        <methods>
          <objinit>
            <implementation><![CDATA[

#if SIO_USE_STREAMS_INTERFACE == TRUE
oopInterfaceObjectInit(&self->sio.chn, &channel_vmt);
#endif
self->sio.enabled     = (sioevents_t)0;
self->sio.cb          = NULL;
#if SIO_USE_SYNCHRONIZATION == TRUE
self->sio.sync_rx     = NULL;
self->sio.sync_rxidle = NULL;
self->sio.sync_tx     = NULL;
self->sio.sync_txend  = NULL;
#endif

/* Optional, user-defined initializer.*/
#if defined(SIO_DRIVER_EXT_INIT_HOOK)
SIO_DRIVER_EXT_INIT_HOOK(self);
#endif]]></implementation>
          </objinit>
          <dispose>
            <implementation><![CDATA[ ]]></implementation>
          </dispose>
        </methods>
      </class>
    </classes>
    <functions>
      <function name="sioInit">
        <brief>SIO Driver initialization.</brief>
        <note>This function is implicitly invoked by @p halInit(), there
          is no need to explicitly initialize the driver.</note>
        <implementation><![CDATA[

sio_lld_init();]]></implementation>
      </function>
    </functions>
  </public>
  <private>
    <inclusions>
      <include style="regular">hal.h</include>
    </inclusions>
    <functions>
      <function name="__sio_start">
        <param name="ip" ctype="void *" />
        <implementation><![CDATA[
hal_sio_driver_c *siop = (hal_sio_driver_c *)ip;
msg_t msg;

msg = sio_lld_start(siop);
if (msg == HAL_RET_SUCCESS) {
#if SIO_USE_SYNCHRONIZATION == TRUE
  /* If synchronization is enabled then all events by default.*/
  sioWriteEnableFlagsX(siop, SIO_EV_ALL_EVENTS);
#else
  /* If synchronization is disabled then no events by default.*/
  sioWriteEnableFlagsX(siop, SIO_EV_NONE);
#endif
}]]></implementation>
      </function>
    </functions>
  </private>
</module>