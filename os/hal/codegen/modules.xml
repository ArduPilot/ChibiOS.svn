<?xml version="1.0" encoding="UTF-8"?>
<instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://www.chibios.org/xml/schema/ccode/modules.xsd">
  <configuration_settings>
  </configuration_settings>
  <modules>
    <module name="hal_base_driver_test">
      <doc>
        <brief>Common driver base abstract class.</brief>
        <details>This abstract class is the common ancestor of all HAL
          stateful HAL drivers.
        </details>
        <note>This is a generated file, do not edit directly.</note>
      </doc>
      <public>
        <configs>
          <config name="HAL_USE_MUTUAL_EXCLUSION" default="TRUE">
            <brief>Enables the mutual exclusion APIs on driver
              instances.</brief>
            <note>Disabling this option saves both code and data space.
            </note>
          </config>
          <config name="HAL_USE_REGISTRY" default="FALSE">
            <brief>Enables the HAL registry for drivers.</brief>
            <note>Disabling this option saves both code and data space.
            </note>
          </config>
        </configs>
        <inclusions>
          <include scope="global" style="regular">hal.h</include>
        </inclusions>
        <definitions>
          <members group="Common driver states">
            <define name="HAL_DRV_STATE_UNINIT" value="0U" />
            <define name="HAL_DRV_STATE_STOP" value="1U" />
            <define name="HAL_DRV_STATE_READY" value="2U" />
            <define name="HAL_DRV_STATE_ACTIVE" value="3U" />
            <define name="HAL_DRV_STATE_ERROR" value="4U" />
          </members>
        </definitions>
        <macros>
        </macros>
        <typedefs>
          <typedef ctype="driver_state_t">
            <brief>Type of a driver state variable.</brief>
            <reftype ctype="unsigned int" />
          </typedef>
        </typedefs>
        <classes>
          <class name="base_driver" ancestor="base_object"
            descr="base driver" type="abstract">
            <brief>
            </brief>
            <details>
            </details>
            <fields>
              <field name="state" ctype="driver_state_t" />
              <field name="opencnt" ctype="unsigned int" />
              <field name="owner" ctype="void$I*" />
              <field name="mutex" ctype="mutex_t" />
            </fields>
            <init>
              <implementation><![CDATA[ ]]></implementation>
            </init>
            <dispose>
              <implementation><![CDATA[ ]]></implementation>
            </dispose>
            <methods>
              <method name="__drv_start_protected"
                shortname="start" ctype="msg_t" type="virtual">
                <brief>Low level driver start.</brief>
                <return>The operation status.</return>
              </method>
              <method name="__drv_stop_protected"
                shortname="stop" ctype="void" type="virtual">
                <brief>Low level driver stop.</brief>
              </method>
              <method name="drvConfigureX" shortname="configure"
                ctype="msg_t" type="virtual">
                <brief>Driver configure.</brief>
                <details>
                  Applies a new configuration to the driver. The configuration
                  structure is architecture-dependent.
                </details>
                <note>
                  Applying a configuration should be done while the peripheral
                  is not actively operating, this function can fail depending
                  on the driver implementation and current state.
                </note>
              </method>
              <method name="drvGetInterfaceX" shortname="getif"
                ctype="const void *" type="virtual">
                <brief>Driver interface get.</brief>
                <return>The driver interface or @p NULL if none.
                </return>
              </method>
              <method name="drvOpen" shortname="open"
                ctype="msg_t" type="regular">
                <brief>Driver open.</brief>
                <details>
                  Returns a reference to the driver, on the 1st open the peripheral
                  is physically initialized. An implementation-dependent default
                  configuration is used for initialization.
                </details>
                <return>The operation status.</return>
                <implementation><![CDATA[
msg_t msg;

osalDbgCheck(self != NULL);

osalSysLock();

if (self->opencnt == 0U) {
  /* Physically starting the peripheral.*/
  msg = __drv_protected_start(self);
  if (msg == HAL_RET_SUCCESS) {
    self->opencnt++;
    self->state = HAL_DRV_STATE_READY;
  }
  else {
    self->state = HAL_DRV_STATE_STOP;
  }
}
else {
  msg = HAL_RET_SUCCESS;
}

osalSysUnlock();

return msg;]]></implementation>
              </method>
              <method name="drvClose" shortname="close"
                ctype="void" type="regular">
                <brief>Driver close.</brief>
                <details>
                  Releases a reference to the driver, when the count reaches zero
                  then the peripheral is physically uninitialized.
                </details>
                <implementation><![CDATA[
osalDbgCheck(self != NULL);

osalSysLock();

osalDbgAssert(self->opencnt > 0U, "not opened");

if (--self->opencnt == 0U) {
  self->state = HAL_DRV_STATE_STOP;
  self->vmt->stop(self);
}

osalSysUnlock();]]></implementation>
              </method>
              <method name="drvGetStateX" ctype="driver_state_t"
                type="regular">
                <brief>Driver state get.</brief>
                <return>The driver state.</return>
                <implementation><![CDATA[return self->state;]]></implementation>
              </method>
              <method name="drvSetStateX" ctype="void"
                type="regular">
                <brief>Driver state set.</brief>
                <param ctype="driver_state_t" name="state">New driver
                  state.</param>
                <implementation><![CDATA[self->state = state;]]></implementation>
              </method>
              <method name="drvGetOwnerX" ctype="void *"
                type="regular">
                <brief>Driver owner get.</brief>
                <return>The driver owner.</return>
                <implementation><![CDATA[return self->owner;]]></implementation>
              </method>
              <method name="drvSetStateX" ctype="void"
                type="regular">
                <brief>Driver owner set.</brief>
                <param ctype="void *" name="state">New driver owner.
                </param>
                <implementation><![CDATA[self->owner = owner;]]></implementation>
              </method>
              <method name="drvLock" ctype="void" type="regular">
                <brief>Driver lock.</brief>
                <implementation><![CDATA[osalMutexLock(&self->mutex);]]></implementation>
              </method>
              <method name="drvUnlock" ctype="void"
                type="regular">
                <brief>Driver unlock.</brief>
                <implementation><![CDATA[osalMutexUnlock(&self->mutex);]]></implementation>
              </method>
            </methods>
          </class>
        </classes>
      </public>
      <private>
        <definitions>
          <members group="Common driver states">
            <define name="HAL_DRV_STATE_UNINIT" value="0U" />
          </members>
        </definitions>
      </private>
    </module>
  </modules>
</instance>
